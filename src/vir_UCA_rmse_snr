import numpy as np
from tqdm import tqdm
from scipy.signal import find_peaks
import matplotlib.pyplot as plt

def vir_UCA(Nr: int, Nt: int, P: int, SNR: float, N_test: int = 1):
    # ===== Constants =====
    c_c = 3e8
    c_fc = 39e6
    Ne = Nt
    d_d = c_c / (8 * c_fc * np.sin(np.pi/Nr)**2)

    # True DoA
    theta_deg_true = np.array([-60, -45, -30, 0, 15, 30, 45, 60])
    theta_rad_true = np.deg2rad(theta_deg_true)

    # QPSK generator
    def s_qpsk(P: int):
        const = np.array([np.exp(1j*np.pi/4), np.exp(3j*np.pi/4),
                          np.exp(5j*np.pi/4), np.exp(7j*np.pi/4)])
        return np.random.choice(const, size=(P,1))

    sigma = 10**(-SNR/10)
    err_list = []

    last_spectrum = None
    last_theta_deg = None

    for _ in tqdm(range(N_test), desc=f"Processing MUSIC SNR={SNR}dB", ncols=100, unit="iteration"):
        # Covariance matrix
        R = np.zeros((Nr,Nr), dtype=complex)
        for m in range(Nr):
            for n in range(Nr):
                s_m, s_mn = np.zeros((P,1), complex), np.zeros((P,1), complex)
                for theta in theta_rad_true:
                    s_base = s_qpsk(P)
                    phi_m  = 2*np.pi*c_fc*d_d/c_c * np.cos(theta - 2*np.pi*m/Nr)
                    phi_mn = 2*np.pi*c_fc*d_d/c_c * np.cos(theta - 2*np.pi*(m+n)/Nr)
                    s_m  += s_base*np.exp(1j*phi_m)
                    s_mn += s_base*np.exp(1j*phi_mn)

                # Add noise
                s_m  += sigma/np.sqrt(2)*(np.random.randn(P,1)+1j*np.random.randn(P,1))
                s_mn += sigma/np.sqrt(2)*(np.random.randn(P,1)+1j*np.random.randn(P,1))

                if m+n < Nr and n!=0:
                    R[m,m+n] = np.mean(s_m*np.conj(s_mn))
                    R[m+n,m] = np.conj(R[m,m+n])
                elif n==0:
                    R[m,m] = np.mean(s_m*np.conj(s_m))

        # MUSIC
        eigval, eigvec = np.linalg.eig(R)
        idx_order = np.argsort(np.abs(eigval))
        noise_space = eigvec[:, idx_order[:Nr-Ne]]

        theta_grid = np.linspace(-np.pi/2, np.pi/2, 720)
        spectrum = []
        for th in theta_grid:
            a = np.exp(2j*np.pi*c_fc*d_d/c_c * np.cos(th - 2*np.pi*np.arange(Nr)/Nr)).reshape(-1,1)
            Pm = 1 / (a.conj().T @ noise_space @ noise_space.conj().T @ a).item()
            spectrum.append(10*np.log10(np.abs(Pm)))
        spectrum = np.array(spectrum)

        # Peak detection
        peaks, _ = find_peaks(spectrum, height=5, distance=10, prominence=2)
        est_deg = [-90 + (180*i/(len(theta_grid)-1)) for i in peaks]
        est_deg = sorted(est_deg[:Ne])

        if len(est_deg) >= Ne:
            se = np.sum((np.array(est_deg)-theta_deg_true)**2)/Ne
            err_list.append(se)

        last_spectrum = spectrum - np.max(np.abs(spectrum))
        last_theta_deg = np.rad2deg(theta_grid)

    rmse = np.sqrt(np.mean(err_list)) if err_list else np.nan
    print(f"RMSE MUSIC @ {SNR} dB over {N_test} runs: {rmse:.4f}")

    return last_theta_deg, last_spectrum, rmse

# ==== Example usage ====
d_Nr = 12         # Number of virtual antennas
d_Nt = 8          # Number of sources
d_P = 2000        # Number of snapshots
d_SNR = 20        # Signal-to-noise ratio
d_N_test = 10     # Number of Monte Carlo runs
theta_grid, music_spec, rmse = vir_UCA(d_Nr, d_Nt, d_P, d_SNR, d_N_test)

# Plot last MUSIC spectrum
plt.figure(figsize=(10,6))
plt.plot(theta_grid, music_spec, 'b-', label="Normalized D-MUSIC Spectrum")
for ang in [-60, -45, -30, 0, 15, 30, 45, 60]:
    plt.axvline(x=ang, color='r', ls='--', alpha=0.5)
plt.title(f"MUSIC Spectrum @ {SNR} dB (last run)")
plt.xlabel("Angle (deg)"); plt.ylabel("Power (dB)")
plt.grid(True); plt.legend(); plt.tight_layout()
plt.show()
